# 定位问题才能更好地解决问题

## 问题定位和技术选型

### 处理实际的算法问题时的思考路径

1. 明确目标，用尽可能低的时间复杂度和空间复杂度解决问题并编写出代码。

2. 定位问题，目的是更高效的解决问题，如何定位呢？参考如下：

- 问题是什么类型？是排序，查找还是最优化？
- 问题的复杂度下限(即，最低的时间复杂度可能)是多少？
- 采用什么数据结构和算法思维解决问题？

3. 示例演示如下：

Q：在一个包含 n 个元素的无序数组 a 中，输出最大值 max_val?

3.1 定位问题：

问题类型 - 在数据中基于某个条件查找问题，思考查找算法：

- 考虑二分查找(复杂度是 O(logn))，但二分查找的条件时数据时有序的，不满足当前情况。
- 由于必须要检索所有数据，可以考虑用 O(n)的算法，这就是**复杂度的下限**。

### 通用的解题方法

1. 遇到一些复杂的问题时，是否有一些通用的解决方法呢？

1.1 **从复杂度入手，尝试分析：**

该问题的时间复杂度上限是多少？即不计任何时间、空间损耗，采用暴力求解的方法去解决。

找到问题时间复杂度的下限？进一步思考该问题的时间复杂度可以再低吗？这就是编写代码的目标。

1.2 **尝试定位问题：**

设计合理的数据结构和运用合适的算法思维，从暴力求解的方法去逼近写代码的目标。

先定位问题，**问题的类型决定了采用那种算法思维。**

1.3 **需要对数据操作进行分析**

例如：

- 需要对数据进行哪些操作(增删查)，数据之间是否需要保证顺序或逆序。
- 当分析出哪些操作的步骤、频次之后，可以根据不同的数据结构的特性，去合理选择应该使用的数据结构。

### 案例分析

1. 在一个数组 a=[1, 2, 3, 4, 4, 1, 3]，找到出现次数最多的那个数字，如果并列存在多个，随机输出一个。

暴力解法 - 双层循环：

- 第一层循环，对数组中每个元素进行遍历。
- 第二层，对每个元素计算出现的次数。

这样实现的代码的时间复杂度是 O(n^2)。

接着分析，发现它的**最低复杂度是 O(n)。**

问题归类，属于**在一个数组中，根据某个条件进行查找的问题。**因为复杂度不会低于 O(n)，所以不会考虑「二分查找」了。

那么，如何让 O(n^2)的复杂度降低为 O(n)呢？

分析数据特征发现，实现不需要关注「数据顺序」，所以，不会用到栈、队列等数据结构。

另外，由于问题是一个高频「查找」的问题，可以使用**哈希表**解决。

哈希表的结构是“key-value”的键值对，如何设计键和值呢？

- 哈希表查找的 key，所以 key 一定存放的是被查找的内容，即原数组中的元素。
- 哈希表中 key 不能重复，只能用 value 保存频次。

最后总结所有解决方案需要用到的关键因素：

- 预期的时间复杂度 O(n)，即需要一层 for 循环，对原数组进行遍历。
- 数据结构需要额外的哈希表，其中 key 是数组的元素，value 是频次，完成 O(1)的查找动作。

代码实现：

```ts
function main() {
  const arr = [1, 3, 4, 3, 1, 3, 1];
  const dist = new HashMap();

  for (let i = 0; i < arr.length; i++) {
    if (dist.containsKey(arr[i])) {
      dist.put(arr[i], dist.get(arr[i] + 1));
    } else {
      dist.put(arr[i], 1);
    }
  }

  let valMax = -1,
    timeMax = 0;

  for (let key in dist.keySet()) {
    if (dist.get(key) > timeMax) {
      timeMax = dist.get(key);
      valMax = key;
    }
  }
}
```

2. 给定一个整数数组 arr 和一个目标值 target，在数组中找出加和等于目标值的两个整数，返回它们在原数组中的下标值，另外：

- 原数组中没有重复元素，而且有且只有一个答案。
- 数组中的元素只能使用一次。

示例：arr = [1, 2, 3, 4, 5, 6]，target = 4，返回： 0 和 2。

思路如下：

2.1 暴力解法 - 两层循环：

- 一层循环，遍历每个数据。
- 二层循环，查找对于第一层循环的元素与 target 的差值。

最后实现的时间复杂度是 O(n^2)。

又由于某个数字是否存在于原数组对结果有影响，因此，最低时间复杂度 O(n)。

分析发现，问题属于「在数组中基于某个条件去查找数据」，且原数组是无序的，不能使用二分查找。

那么如何 O(n^2)的复杂度降低到 O(n)呢？

在「暴力解决」的方法中，第二层循环的目的是查找 target - arr[i]是否出现在数组中，可以考虑使用**哈希表**解决。

实现思路：

- 预期的时间复杂度 O(n)，即需要一层 for 循环，对原数组进行遍历。
- 数据结构需要额外的哈希表，其中哈希表的 key 使用 target - arr[i]，value 是 index 索引值，支持 O(1)时间复杂度的查询。

代码实现：

```ts
function main(arr: number[], target: number) {
  const map = new HashMap();
  for (let i = 0; i < arr.length; i++) {
    map.put(arr[i], i);
  }

  for (let i = 0; i< arr.length; i++) {
    const delta = target = arr[i];

    if (map.containsKey(delta) && map.get(delta) !== i) {
      return {
        map.get(delta),
        i
      }
    }
  }
}
```

性能分析：

- 时间复杂度：O(n) + O(n) = O(n)。
- 空间复杂度：O(n)。

## 要点

1. 编码中，遇到复杂的问题时，一个通用的思考路径是：

- 复杂度分析 - 估算问题中复杂度的上限和下限。
- 定位问题 - 根据问题类型，确定采用何种算法思维。
- 数据操作分析 - 根据增、删、查和数据顺序关系去选择合适的数据结构，利用空间换时间。
- 编码实现。

2. 记住：解决问题的思考模型(路径或方式)优于解决方案。

3. 在开发前，一定要对问题的复杂度进行分析，做好技术选型，这就是**定位问题的过程，**做好这个过程，是为了更好的解决问题。
