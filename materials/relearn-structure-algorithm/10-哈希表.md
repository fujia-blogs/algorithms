# 哈希表

> 高效率查找的“利器”

1. 常见数据结构的对比：

- 线性表中的栈和队列对增删有严格要求，它们会更关注数据的顺序。
- 数组和字符串需要保持数据类型的统一(数组在不同语言有不同的实现)，且基于索引的查找会更有优势。
- 树的优势则体现在数据层次结构上。

共同的不足是：数据数值条件的查找，都需要对全部数据或部分数据进行遍历。

2. 什么是哈希表？

哈希表(hash)，也称作散列表，是一种特殊的数据结构。

3. 哈希表的核心思想？

哈希表的设计采用了**函数映射的思想**，将记录的存储位置与记录的关键字关联起来，这样的设计方式，能够快速定位到想要查找的记录，且不需要与表中存在的记录的关键字比较厚再来进行查找。

类比思考：

数组是通过**数据的索引(index)来取出数值的，**如数组 a，通过 a[0]取出这个数据。通过这种方式，数组实现了“地址=f(index)”的映射关系，如果用哈希表的逻辑来理解，这里的 f()就是一个哈希函数，它完成了索引值到实际地址的映射。

但数组有一个局限性，即**只能基于数据的索引去查找，而不能基于数据的数值去查找。**

如果有一种方法，可以实现“地址=f(关键字)的映射关系”，就可以快速完成基于数据的数值来查找了，这就是**哈希表的核心思想。**

4. 哈希函数设计的好坏会直接影响对哈希表的操作效率。

5. 哈希表需要设计合理的哈希函数，且对冲突有一套处理机制。

6. 哈希表的优势？

可以非常快速的插入-删除-查找操作，无论多少数据，插入和删除值需要接近常量的时间。

在查找方面，哈希表的速度比树还要快，基本可以瞬间查找到想要的元素。

7. 哈希表的不足？

- 哈希表中的数据是没有顺序概念的，所以不能以一种固定的方式(如: 从小到大)来遍历其中的元素，在处理顺序敏感的数据时，哈希表不是一个好的选择。
- 哈希表中的 key 是不允许重复的，在「重复性」非常高的数据集中，哈希表也不是一个好的选择。

### 哈希冲突

> 从本质上来看，哈希冲突只能尽可能减少，不能完全避免。原因是：数据的输入是一个开发集合，只要数量够多，分布够广，发生冲突的概率就越大。

1. 一旦发生哈希冲突，如何解决？

- 开放定制法

当一个关键字和另一个关键字发生冲突时，使用某种探测技术在哈希表中形成一个探测序列，然后沿着这个探测序列依次查找下去，当碰到一个空单元时，则插入其中

常用的探测方法是**线性探测法。**

- 链地址法

将哈希地址相同的记录存储在一张线性链表中。

## 哈希函数

### 设计哈希函数

1. 直接定制法

哈希函数为：关键字到地址的线性函数，如 H(key) = a \* key + b。a 和 b 是设置好的常数。

2. 数字分析法

假设关键字集合中的每个关键字 key 都是由 s 位数字组成(k1, k2, ..., Ks)，从中提取分布均匀的若干位组成哈希地址。

3. 平方取中法

如果关键字的每一位都有某些数字重复出现，且频率很高，可以先求关键字的平方值，通过平方扩大差异，然后取中间几位作为最终存储地址。

4. 折叠法

如果关键字的位数很多，可以将关键字分割为几个等长的部分，取它们的叠加和的值(舍去进位)作为哈希地址。

5. 除留余数法

预先设置一个树 p，然后对关键字进行祛瘀运算。即地址为 key mod p。

## 哈希表的基本操作

1. 很多高级语言中，哈希函数。哈希冲突都已经在底层完成了黑盒化的处理。

2. 哈希表中的增加和删除操作，不涉及增删后对数据的挪移问题(数组需要考虑)

3. 哈希表查找的细节过程：对于给定的 key，通过哈希函数计算哈希地址 H(key)

- 如果哈希地址对应的值为空，则查找不成功。
- 反之，则查找成功。

## 要点

1. 无论哈希表中有多少数据，查找、插入，删除只需要接近常量的时间，即 O(1)的时间级。

- 哈希表运算非常快，如果需要在 1s 内查找上千条记录通常使用哈希表(如：拼写检查器)。
- 哈希表的速度比树快，树的操作通常需要 O(n)的时间级。

2. 哈希表不仅速度快，编程实现也相对容易。

3. 如果不需要有序遍历数据，且可以提前预测数据量的大小，**哈希在速度和应用性方面是无与伦比的。**
