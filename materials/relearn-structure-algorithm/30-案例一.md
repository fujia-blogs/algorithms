# 案例

## 链表

1. 链表的翻转

Q: 给定一个链表，输出翻转后的链表，如： 1 -> 2 -> 3 -> 4 -> 5 => 5 -> 4 ->3 -> 2 -> 1

S: 构造三个指针：prev, next, cur，对当前的节点，之前和之后的结点进行缓存。

2. 给定一个奇数个元素的链表，查找出这个链表的中间位置的结点的数值

> 这个问题也是利用链表查找长度无法获取的不足做文章

S1：一次遍历计算链表的长度，再通过一次遍历查找这个位置的数值(暴力)

S2：利用**快慢指针**进行处理(推荐)

- 快指针：每次循环向后跳转两次
- 慢指针：每次循环向后跳转一次

```ts
while (fast && fast.next && fast.next.next) {
  fast = fast.next.next;
  slow = slow.next;
}
```

3. 判断链表是否有环？

S：利用**快慢指针**进行处理(推荐)

- 快指针：每次循环向后跳转两次
- 慢指针：每次循环向后跳转一次

如果链表中有环，快指针和慢指针一定会相遇，反之，不会相遇。

## 栈

1. 给定一个包括'(', ')', '{', '}', '[', ']'的字符串，判断字符串是否有效？有效地字符串需要满足：左括号必须与相同类型的右括号匹配，左括号必须以正确的顺序匹配

示例：{[()()]}是合法的，而{([)]}是非法的

S1: 在匹配括号是否合法时，左括号是从左到右依次出现，而右括号则需要“后进先出”的顺序依次与左括号匹配，实现方案：使用栈

具体实现：从左到右遍历字符串，当出现“左括号时”压栈，当出现右括号时出栈，且判断当前的右括号与被出栈的左括号是否匹配? 如果不是，则字符串非法，如果遍历完成，栈为空，则为合法

```ts
function isLeft(c: string) {
  if (c === '{' || c === '(' || c === '[') {
    return 1;
  } else {
    return 2;
  }
}

function isPair(p: string, cur: string) {
  if (
    (p === '{' && cur === '}') ||
    (p === '[' && cur === ']') ||
    (p === '(' && cur === ')')
  ) {
    return 1;
  } else {
    return 0;
  }
}

function isLegal(s: string) {
  const stack = new Stack();

  for (let i = 0; i < s.length; i++) {
    const cur = s.charAt(i);

    if (isLeft(cur) === 1) {
      stack.push(cur);
    } else {
      if (stack.empty()) {
        return false;
      }

      const p = stack.pop();

      if (isPair(p, cur) === 0) {
        return false;
      }
    }
  }

  if (stack.empty()) {
    return true;
  } else {
    return false;
  }
}
```

2. 浏览器的页面访问都包含了后退和前进功能，利用栈如何实现？

为了支持前进、后退的功能，可以利用栈来记录用户历史访问网页的顺序信息，**需要维护两个栈，分别用来支持后退和前进：**

- 用户访问一个新的页面，则对「后退栈」进行压栈操作
- 当用户后退一个页面，则「后退栈」进行出栈，同时「前进栈」执行压栈
- 当用户前进了一个页面，则「前进栈」出栈，同时「后退栈」压栈
