# 树和二叉树

1. 什么是树？

树是由结点和边组成的，不存在环的一种数据结构。

- 树满足递归定义的特性，即一个数据结构是树结构，那剔除根节点后得到若干个子结构也是树，也叫做子树。

2. 树中的结点名称：

- 父结点、子结点。
- 同一个父结点的结点称为兄弟结点。
- 没有父结点的结点称为**根结点**。
- 没有子结点的结点，称为叶子结点。

3. 有了一棵树后，还需要用「深度」和「层」来描述结点的位置。根结点为第 1 层，树中最大结点的层次就是树的树深。

## 二叉树

1. 什么是二叉树？

二叉树，每个结点最多有两个分支，即每个结点最多有两个子结点，分别称为「左子结点」和「右子结点」。

2. 满二叉树：除了叶子结点外，所有的结点都有两个子结点。

3. 完全二叉树：除了最后一层以外，其它层的结点个数都达到最大，且最后一层的叶子结点都靠左排列。**之所以成为完全二叉树，是从存储空间利用效率的视角来看的**

4. 存储二叉树的两种办法：

- 基于指针的链式存储法，像链表一样，每个结点有三个字段，一个存储数据，另外两个存储指向左右子结点的指针。
- 基于数组的顺序存储法，按照规律把结点存放在数组里。

5. 顺序存储中，为了方便计算，一般约定把「根结点」放在下标为 1 的位置，其左子结点放在下标为 2 的位置，右子结点放在下标为 3 的位置，依此类推。

根据这种规律，如果结点 X 的下标为 i：

- X 的左子结点总是存放在 2 \* i 的位置。
- X 的右子结点总是存放在 2 \* i + 1 的位置。

### 树的操作

> 以二叉树为例，其他树的操作基本类似。

1. 树结构是“一对多”的关系，即前面的父结点跟下面若干个子结点产生了连接关系。

2. 如何进行数据遍历才能保证每条数据都会被访问一次且没有遗漏呢？

- 遍历一棵树的三个经典方法：前序遍历、中序遍历、后序遍历。

注意，上面的「序」指的是父结点的遍历顺序：

- 「前序」是先遍历父结点
- 「中序」是中间遍历父结点
- 「后序」是最后遍历父结点

不管是那种遍历，都是通过递归调用完成的。

```ts
// 前序遍历
function preOrderTraverse(node: Node) {
  if (node === null) return;

  console.log(node.data + ' ');
  preOrderTraverse(node.left);
  preOrderTraverse(node.right);
}

// 中序遍历
function inOrderTraverse(node: Node) {
  if (node === null) return;

  preOrderTraverse(node.left);
  console.log(node.data + ' ');
  preOrderTraverse(node.right);
}

// 后序遍历
function preOrderTraverse(node: Node) {
  if (node === null) return;

  preOrderTraverse(node.left);
  preOrderTraverse(node.right);
  console.log(node.data + ' ');
}
```

3. 二叉树遍历的过程中，每个结点都被访问了一次，其时间复杂度是 O(n)。

- 对没有任何特殊性质的二叉树而言，真正执行增加和删除操作的时间复杂度是 O(1)。
- 树数据的查找操作和链表一样，都需要遍历每一个数据去判断，时间复杂度是 O(n)。

### 二叉查找树(也称为二叉搜索树)

1. 特性：

- 树中任意一个结点，其左子树中的每个结点的值，都要小于这个结点的值。
- 树中任意一个结点，其右子树中的每个结点的值，都要大于这个结点的值。
- 尽可能规避两个结点数值相等的情况。
- 执行中序遍历后，就可以输出一个从小到大的有序数据队列。

2. 使用二叉查找树执行查找操作：

- 首先判断根结点是否等于要查找的数据，如果是就返回。
- 如果根结点大于要查找的数据，就在左子树中递归查找动作，直到叶子结点。
- 如果根结点小于要查找的数据，就在右子树中递归查找动作，直到叶子结点。

**这样的“二分查找”所消耗的时间复杂度就可以降为 O(logn)。**

3. 插入操作：从根结点开始，如果要插入的数据比根结点的数据大，且根结点的右子结点不为空，则在根结点的右子树中继续尝试执行插入操作，直到找到为空的子结点执行插入操作动作。

- 插入数据的时间复杂度是 O(logn)，注意：时间复杂度更多是消耗在遍历数据上，真正插入动作的时间复杂度仍然是 O(1)。

4. 删除操作

> 删除比较复杂，因为删除一个结点后的树仍需要满足二叉查找树的性质。

4.1. 删除的结点是一个叶子结点，直接删除，将其父结点指针指向 null

4.2. 删除的结点只有一个子结点，只需要将其父结点指向的子结点的指针换成其子结点的指针。

4.3. 删除的结点有两个子结点，则有两种操作方式：

- 找到这个结点的左子树中最大的结点，替换要删除的结点。
- 找到这个结点的右子树中最小的结点，替换要删除的结点。

### 字典树(也称为 Trie 树)

1. 特点：

- 根结点不包含字符。
- 除根结点外每一个结点都只包含一个字符
- 从根结点到某一叶子节点，路径上经过的字符连接起来，即为集合中的某个字符串。

## 要点

1. 树结构在存在"一对多"的数据关系中，可被高频使用。
